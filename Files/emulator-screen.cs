using System;
using Microsoft.Xna.Framework;
using Microsoft.Xna.Framework.Graphics;

namespace Chip8Emu.IO;

class Chip8Screen
{
    Texture2D pixel;
    Rectangle pixel_rect;
    Point position;
    const byte bits_in_byte = 8;
    const byte scr_width = 64;
    const byte scr_heigth = 32;
    const byte scr_w_bytes = scr_width / bits_in_byte;
    byte[] screen_state;
    public Chip8Screen(int x, int y, int _scr_width, int _scr_heigth)
    {
        position = new(x, y);
        int min_dim = MathHelper.Min(_scr_width / scr_width, _scr_heigth / scr_heigth);
        pixel_rect = new(position, new(min_dim));
        
        
        //scr_w_bytes * scr_h_bytes
        screen_state = new byte[scr_w_bytes * scr_heigth]{
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe, 0xfe,}
        ;
    }
    public void Clear()
    {
        screen_state = new byte[scr_w_bytes * scr_heigth];
    }
    public void Load(GraphicsDevice g)
    {
        pixel = new(g, 1, 1);
        pixel.SetData(new Color[] { Color.White });
    }

    public void Draw(SpriteBatch g)
    {
        int current_pixel;
        for (int i=0; i<screen_state.Length; i++ )
        {
            for (byte j=0; j<bits_in_byte; j++)
            {
                if ((screen_state[i] & (1<<j) )!= 0)
                {
                    current_pixel = i * bits_in_byte + j;
                    pixel_rect.X = (current_pixel % scr_width) * pixel_rect.Width + position.X;
                    pixel_rect.Y = (current_pixel / scr_width) * pixel_rect.Height + position.Y;
                    g.Draw(pixel, pixel_rect, Color.MonoGameOrange);
                }
                
            }
        }
    }
}